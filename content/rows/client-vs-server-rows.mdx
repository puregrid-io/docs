---
title: Client vs Server Rows
description: Learn when and how to user client and server side rows
---

## Client vs Server

There are two ways of working with data and rows: clientside or serverside.

Clientside rows expect all your grid data upfront and so manipulation of your data into rows can be done on the client. This includes: pagination, sorting, filtering, and grouping. To create clientside rows you pass your data along with options to `useClientRows` and you get `rows` out of the hook to pass into the grid.

It may not be efficient or feasible to deliver all your data at once. In that case you can eschew `useClientRows` altogether for generating your rows on the server. This means that as the user pages through, filters, or sorts you have to requests to your server in whatever way suits, and receive rows back.

## Clientside rows

Clientside rows are generated by the `useClientRows` hook. There are 3 required props:

```ts:title=Required+useClientRows+props
const rows = useClientRows<Candidate>({
  columns,
  data,
  getItemId: candidate => candidate.uid,
});
```

If your data doesn't have a unique ID then map over it **once** and add one, even a simple incrementing counter is fine as long as it's only done once.

Additionally you can pass in the following optional props:

##### pageSize

Set the size of pages. Defaults to 20. See [Pagination](rows/pagination).

##### pageIndex

The current page index. See [Pagination](rows/pagination).

##### rowState

When using row state for row selection or expansion you should pass the row state in here. See [Row State](rows/row-state).

##### filterState

Pass the filter state when using column fitlers. See [Column Filtering](columns/column-filtering).

##### filterMethods

Pass custom filter methods in here. See [Column Filtering](columns/column-filtering).

##### globalFilter

A filter value to apply to all columns. See [Column Filtering](columns/column-filtering).

##### globalFilterCache

Whether to cache row values for faster global filtering (has a trade-off). See [Column Filtering](columns/column-filtering).

##### globalFilterCache

Pass custom sort methods in here. See [Column Sorting](columns/column-sorting).

##### defaultExpandTo

The default level to expand row groups to. See [Row Grouping](rows/row-grouping).

## Serverside rows

Rather than stipulate how you should handle your data the grid only stipulates that you provide rows of a certain shape. When handling paging, sorting, filtering or grouping yourself you should skip the use of `useClientRows` and ensure that the `rows` follows the prescribed shapes.

These types are of course available for importing if needed.

```ts:title=Row+shapes
enum RowType {
  NormalRow,
  GroupRow,
  DetailsRow,
}

interface GroupRow {
  type: RowType.GroupRow;
  key: string;
  level: number;
  data: {
    colKey: string;
    value: string;
    expanded: boolean;
    childCount: number;
  };
}

interface NormalRow<T> {
  type: RowType.NormalRow;
  key: string;
  level: number;
  data: T;
}

interface DetailsRow<D = any> {
  type: RowType.DetailsRow;
  key: string;
  level: number;
  data: D;
}

type Row<T = unknown> = GroupRow | NormalRow<T> | DetailsRow;
```

These are the same shapes that `useClientRows` produces.

##### key

Should be the unique key for your row. This is what `getItemId` returns for client rows.

##### level

Level is optional and used for [Row Grouping](rows/row-grouping) in case you want to perform some styling or logic in your cells based on group depth. Otherwise it should be `0`.

##### data

The row data whose shape is up to you unless it's a group row which has a fixed shape.
